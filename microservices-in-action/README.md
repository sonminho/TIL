## 컨피그 서버

다수의 마이크로서비스 애플리케이션의 구성정보를 개별로 관리한다면 변경사항이 있을 때마다 코드 저장소에서 파일을 검색, 재기동 해야하며 이를 해결하는 방법은 아래와 같다.

- 배포되는 실제 코드와 구성 정보를 완전히 분리
- 여러 환경에서도 절대 변경되지 않는 불변 `immutable` 애플리케이션 이미지를 빌드
- 서버가 기동될 때 마이크로서비스가 읽어 오는 환경변수 또는 중앙 저장소를 통해 모든 애플리케이션 구성 정보를 주입

마이크로서비스 배포 작업이 수기로 진행된다면 애플리케이션 구성정보 불일치, 예기치 못한 장애가 발생할 수 있음  

1. 분리 _`segregate`_ : 서비스의 물리적 배포 단계에서 구성정보를 완전히 독립시킴, 서비스가 시작할 때 필요한 프로퍼티를 환경번수로 전달 받거나 중앙 저장소에서 읽어들임

2. 추상화 _`abstract`_ : 서비스 인터페이스 뒷단에 있는 구성 데이터의 접근 방식을 추상화(REST 기반 JSON 등)

3. 중앙 집중화 _`centralize`_ : 가능한 적은 수의 저장소로 애플리케이션 구성 정보를 집중시킴 

4. 견고화 _`harden`_ : 애플리케이션 구성 정보는 배포되는 서비스와 완전히 분리되고 중앙 집중화 되므로 사용하고 구현할 술루션은 가용성이 높고 이중화가 필요

<br> 


## 디스커버리 서버

전통적인 중앙 집중식 네트워크의 로드밸런서는 라우팅 테이블에서 서비스를 호스팅하는 서버 목록을 보유하고 있으며 이 중 하나의 서버를 선택하여 요청을 위임한다.

고가용성을 위한 서브 로드밸런서는 메인 로드밸런서의 활성상태를 확인하기 위해 주기적으로 핑 신호를 보낸다.

전통적인 로드밸런서는 대부분 고정적으로 관리되며 중앙 집중식 DB를 사용하여
경로 규칙을 저장하며 공급업체의 독점적인 API를 사용해야하만 새로운 경로를 저장할 수 있다.

클라우드 기반 마이크로서비스 환경에서 서비스 디스커버리는 고가용성, P2P`peer-to-peer`, 부하분산`Load balanced`, 회복성`resilient`, 결함 내성`fault tolerant` 등의 특징이 있다.

<br>

- 고가용성
    - 서비스 디스커버리 클러스터의 노드 간 서비스 검색 정보가 공유되는 핫 클러스터링 환경을 지원할 수 있어야 한다. 한 노드가 가용하지 않으면 클러스터 내 다른 노드가 그 역할을 대신해야 한다. 

- P2P
    - 서비스 디스커버리 클러스터의 모든 노드는 서비스 인스턴스의 상태를 상호 공유한다.

- 부하분산
    - 서비스 디스커버리는 요청을 동적으로 분산시켜 관리하고 있는 모든 서비스 인스턴스에 분배해야 한다. 고정적이며 수기로 관리되는 기존 로드밸런서를 대체할 수 있어야 한다. 
  
- 회복성
    - 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐싱`caching` 해야한다.

- 결함 내성
    - 비정상 서비스 인스턴스를 탐지하면 클라이언트 요청을 처리하는 가용 서비스 목록에서 해당 인스턴스를 제거해야 한다. 서비스를 이용하여 이러한 결함을 탐지하고 사람의 개입 없이 조치되어야 한다.
