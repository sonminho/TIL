## 컨피그 서버

다수의 마이크로서비스 애플리케이션의 구성정보를 개별로 관리한다면 변경사항이 있을 때마다 코드 저장소에서 파일을 검색, 재기동 해야하며 이를 해결하는 방법은 아래와 같다.

- 배포되는 실제 코드와 구성 정보를 완전히 분리
- 여러 환경에서도 절대 변경되지 않는 불변 `immutable` 애플리케이션 이미지를 빌드
- 서버가 기동될 때 마이크로서비스가 읽어 오는 환경변수 또는 중앙 저장소를 통해 모든 애플리케이션 구성 정보를 주입

마이크로서비스 배포 작업이 수기로 진행된다면 애플리케이션 구성정보 불일치, 예기치 못한 장애가 발생할 수 있음  

1. 분리 _`segregate`_ : 서비스의 물리적 배포 단계에서 구성정보를 완전히 독립시킴, 서비스가 시작할 때 필요한 프로퍼티를 환경번수로 전달 받거나 중앙 저장소에서 읽어들임

2. 추상화 _`abstract`_ : 서비스 인터페이스 뒷단에 있는 구성 데이터의 접근 방식을 추상화(REST 기반 JSON 등)

3. 중앙 집중화 _`centralize`_ : 가능한 적은 수의 저장소로 애플리케이션 구성 정보를 집중시킴 

4. 견고화 _`harden`_ : 애플리케이션 구성 정보는 배포되는 서비스와 완전히 분리되고 중앙 집중화 되므로 사용하고 구현할 술루션은 가용성이 높고 이중화가 필요

<br> 


## 디스커버리 서버

전통적인 중앙 집중식 네트워크의 로드밸런서는 라우팅 테이블에서 서비스를 호스팅하는 서버 목록을 보유하고 있으며 이 중 하나의 서버를 선택하여 요청을 위임한다.

고가용성을 위한 서브 로드밸런서는 메인 로드밸런서의 활성상태를 확인하기 위해 주기적으로 핑 신호를 보낸다.

전통적인 로드밸런서는 대부분 고정적으로 관리되며 중앙 집중식 DB를 사용하여
경로 규칙을 저장하며 공급업체의 독점적인 API를 사용해야하만 새로운 경로를 저장할 수 있다.

클라우드 기반 마이크로서비스 환경에서 서비스 디스커버리는 고가용성, P2P`peer-to-peer`, 부하분산`Load balanced`, 회복성`resilient`, 결함 내성`fault tolerant` 등의 특징이 있다.

<br>

- 고가용성
    - 서비스 디스커버리 클러스터의 노드 간 서비스 검색 정보가 공유되는 핫 클러스터링 환경을 지원할 수 있어야 한다. 한 노드가 가용하지 않으면 클러스터 내 다른 노드가 그 역할을 대신해야 한다. 

- P2P
    - 서비스 디스커버리 클러스터의 모든 노드는 서비스 인스턴스의 상태를 상호 공유한다.

- 부하분산
    - 서비스 디스커버리는 요청을 동적으로 분산시켜 관리하고 있는 모든 서비스 인스턴스에 분배해야 한다. 고정적이며 수기로 관리되는 기존 로드밸런서를 대체할 수 있어야 한다. 
  
- 회복성
    - 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐싱`caching` 해야한다.

- 결함 내성
    - 비정상 서비스 인스턴스를 탐지하면 클라이언트 요청을 처리하는 가용 서비스 목록에서 해당 인스턴스를 제거해야 한다. 서비스를 이용하여 이러한 결함을 탐지하고 사람의 개입 없이 조치되어야 한다.

<br>

## 클라이언트 회복성

여러 원격 서비스 중 하나가 빈번하게 오류가 발생할 경우, 이슈가 클라이언트 측으로 상향 `upstream` 될 수 있다. 이러한 문제는 모든 서비스로 확산되어 전체 시스템이 장애를 겪을 수 있다.

다음 네 가지 패턴은 원격 서비스 호출의 잦은 장애에 대한 클라이언트 회복성 패턴이다.

    1. 클라이언트 측 로드밸런싱
        - 서비스 디스커버리에서 조회한 마이크로서비스의 엔드포인트를 캐싱

    2. 회로 차단기
        - 서비스 클라이언트가 고장 난 서비스를 계속해서 호출하지 못하게 함

    3. 폴백
        - 호출이 실패할 때 실행 가능한 대안이 있는지 확인

    4. 벌크헤드
        - 서로 다른 호출을 격리하여 성능이 낮은 서비스가 클라이언트의 모든 자원을 점유하지 못하게 함

#### `Resilience4j`
마이크로서비스에서 회복성 패턴을 구현할 수 있는 대중적인 라이브러리 중 하나인 `Hystrix`를 대체하며 회로 차단기, 재시도, 벌크헤드, 속도 제한, 폴백 패턴을 제공한다.

- 회로 차단기 구현  
    원격 호출을 모니터링하는 기능으로 원격 서비스 호출 실패율이 설정한 임계치를 초과할 경우 회로차단기가 열린(`open`) 상태가 된다. 열린 상태에서는 빠른 실패(`fast fail`)를 구현하여 호출한 클라이언트에게 즉시 응답한다.   
    <br> 
    대기시간 이후 반열린 상태로(`half-open`) 상태로 전이하며 실패율이 임계치를 초과하는지 평가하여 열린 상태 또는 닫힌 상태로 전이한다.

- 벌크헤드 구현  
    대규모 요청에서 하나의 서비스에 대한 성능 문제로 자바 컨테이너의 모든 스레드가 최대치에 도달하고 작업이 처리되길 기다리는 동안 새로운 작업 요청들은 후순위로 대기하여 자바 컨테어너가 멈추게 된다.
    - 세마포어 벌크헤드: 세마포어 격리 방식으로 서비스에 대한 동시 요청 수를 제한한다. 한계에 도달하면 요청을 거부한다.
    - 스레드 풀 벌크헤드: 제한된 큐와 고정 스레드 풀을 사용한다. 이 방식은 풀과 큐가 다 찬 경우에만 요청을 거부한다.


    

    